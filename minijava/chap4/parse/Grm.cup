//Doug Ostott
//Joseph Rivera
//Assignment 4: MiniJava Grammar with Abstract Syntax Tree Generation

package parse;

import syntaxtree.*;

action code {:

  // An abbreviation for creating identifiers.
  static Identifier id(String s) {
    return new Identifier(s);
  }

:};

parser code {:

  errormsg.ErrorMsg errorMsg;

  public void syntax_error(java_cup.runtime.Symbol current) {
    report_error("Syntax error (" + current.sym + ")", current);
  }

  public void report_error(String message, java_cup.runtime.Symbol info) {
    errorMsg.error(info.left, message);
  }

  public Grm(java_cup.runtime.Scanner scan, errormsg.ErrorMsg err) {
    this(scan);
    errorMsg = err;
  }

:};

// Notice the type declarations for ID and INTEGER_LITERAL; these are
// the only tokens with non-null semantic values.
terminal String    		ID;
terminal Integer		INTEGER_LITERAL;
terminal			CLASS, PUBLIC, STATIC, VOID, MAIN, STRING,
				RETURN, ELSE, LBRACE, RBRACE, LPAREN,
				RPAREN, LBRACK, RBRACK, SEMICOLON, COMMA;
terminal syntaxtree.Type	INT;
terminal syntaxtree.Type	BOOLEAN;
terminal syntaxtree.Statement	IF;
terminal syntaxtree.Statement	WHILE;
terminal syntaxtree.Statement	PRINTLN;
terminal syntaxtree.Exp		LENGTH;
terminal syntaxtree.Exp		TRUE;
terminal syntaxtree.Exp		FALSE;
terminal syntaxtree.Exp		THIS;
terminal syntaxtree.Exp		NEW;
terminal syntaxtree.Statement	ASSIGN;
terminal syntaxtree.Exp	      	AND;
terminal syntaxtree.Exp		LT;
terminal syntaxtree.Exp		PLUS;
terminal syntaxtree.Exp		MINUS;
terminal syntaxtree.Exp		TIMES;
terminal syntaxtree.Exp		DOT;
terminal syntaxtree.Exp		EXCLAMATION;

// The syntaxtree classes are summarized on page 99.  Note that they have been
// augmented with a pos field to record their position in the source file.

non terminal syntaxtree.Program		Program;
non terminal syntaxtree.MainClass	MainClass;
non terminal syntaxtree.ClassDecl	ClassDecl;
non terminal syntaxtree.VarDecl		VarDecl;
non terminal syntaxtree.MethodDecl	MethodDecl;
non terminal syntaxtree.FormalList	FormalRest;
non terminal syntaxtree.Type		Type;
non terminal syntaxtree.Statement	Statement;
non terminal syntaxtree.Exp             Exp;
non terminal syntaxtree.ExpList		ExpRest;
non terminal syntaxtree.ClassDeclList	ClassDeclList;
non terminal syntaxtree.MethodDeclList	MethodDeclList;
non terminal syntaxtree.FormalList	FormalList;
non terminal syntaxtree.VarDeclList	VarDeclList;
non terminal syntaxtree.StatementList	StatementList;
non terminal syntaxtree.ExpList		ExpList;


precedence left 	AND;
precedence left		LT;
precedence left 	PLUS, MINUS;
precedence left 	TIMES;
precedence left 	EXCLAMATION;
precedence left		LBRACK, DOT;

start with Program;

Program 	::= MainClass:m ClassDecl:c1
		    {: RESULT = new Program(mleft, m, c1); :}
		;		;
MainClass	::= CLASS:c ID:i1 LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING
		    LBRACK RBRACK ID:i2 RPAREN LBRACE Statement:s RBRACE RBRACE
		    {: RESULT = new MainClassDecl(cleft, id(i1), id(i2), s); :}
		;
ClassDeclList	::= ClassDeclList:cL ClassDecl:c
		    {: cL.addElement(c); RESULT = : cL;}
		|   {: RESULT = new ClassDeclList(); :}
		;
ClassDecl	::= CLASS:c ID:i LBRACE VarDeclList:vL MethodDeclList:mL RBRACE
		    {: RESULT = new ClassDeclSimple(cleft,id(i), vL, mL); :}
		;
VarDeclList	::= VarDeclList:vL VarDecl:v
		    {: vL.addElement(v); RESULT = vL; :}
		|   {: RESULT = new VarDeclList(); :}
		;
VarDecl		::= Type:t ID:i SEMICOLON
		    {: RESULT = new VarDecl(ileft, t, id(i)); :}
		;
MethodDeclList	::= MethodDeclList:mL MethodDecl;mD
		    {: mL.addElement(mD); RESULT = mL; :}
		|   {: RESULT = new MethodDecl(); :}
		;
MethodDecl	::= PUBLIC Type:t ID:i LPAREN FormalList:fL RPAREN LBRACE VarDeclList:vL StatementList:sL RETURN Exp:e1 SEMICOLON RBRACE
		    {: RESULT = new MethodDecl(ileft, t, id(i), fL, vL, sL, e1); :}
		;
FormalList	::= Type:t ID:i
		    {: RESULT = new Formal(ileft, t, id(i)); :}
		|   Type:t ID:i COMMA FormalRest:fR
		    {: fR.addElement(new Formal(ileft, t, id(i))); RESULT = fR; :}
		|   {: RESULT = new FormalList(); :}
		;
FormalRest	::= Type:t ID:i
		    {: RESULT = new Formal(ileft, t, id(i)); :}
		|   FormalRest:fR COMMA Type:t ID:i
		    {: fR.addElement(new Formal(ileft, t, id(id))); :}
		;
StatementList	::= Statement:s StatementList:sL
		    {::} //Must do efficiently
		|   {: RESULT = new StatementList(); :}
		;
Statement	::= LBRACE StatementList:sL RBRACE
		    {:RESULT = new Block(sLleft, sL); :}
		|   IF:if LPAREN Exp:e1 RPAREN Statement:s1 ELSE Statement:s2
		    {: Result = new If(ifleft, e1, s1, s2); :}
		|   WHILE:w LPAREN Exp:e1 RPAREN Statement:s
		    {: RESULT = new While(wleft, e1, s); :}
		|   PRINTLN:p LPAREN Exp:e1 RPAREN SEMICOLON
		    {: RESULT = new Print(pleft, e1); :}
		|   ID:i ASSIGN:a Exp:e1 SEMICOLON
		    {: RESULT = new Assign(aleft, id(i), e1); :}
		|   ID:i LBRACK Exp:e1 RBRACK ASSIGN:a Exp:e2 SEMICOLON
		    {: RESULT = new ArrayAssign(aleft, id(i), e1, e2); :}
		;
Exp		::= Exp:e1 PLUS:p Exp:e2
		    {: RESULT = new Plus(pleft, e1, e2); :}
		|   Exp:e1 MINUS:m Exp:e2
		    {: RESULT = new Minus(mleft, e1, e2); :}
		|   Exp:e1 TIMES:t Exp:e2
		    {: RESULT = new Times(tleft, e1, e2); :}
		|   Exp:e1 AND:a Exp:e2
		    {: RESULT = new And(aleft, e1, e2); :}
		|   Exp:e1 LT:lt Exp:e2
		    {: RESULT = new LessThan(ltleft, e1, e2); :}
		|   Exp LBRACK Exp RBRACK
		|   Exp DOT LENGTH
		|   Exp DOT ID LPAREN ExpList RPAREN
		|   INTEGER_LITERAL
		|   TRUE
		|   FALSE
		|   ID
		|   THIS
		|   NEW INT LBRACK Exp RBRACK
		|   NEW ID LPAREN RPAREN
		|   EXCLAMATION Exp
		|   LPAREN Exp RPAREN;
ExpList		::= Exp ExpRest
		|   ;
ExpRest		::= COMMA Exp ExpRest
		|   ;
// Note how CUP gives access to semantic values and positions.
// For example, the identifier i below gives the semantic value of the
// INTEGER_LITERAL token, and ileft gives its position.

Exp		::= Exp:e1 AND:a Exp:e2
			{: RESULT = new And(aleft, e1, e2); :}
		|   INTEGER_LITERAL:i
		    {: RESULT = new IntegerLiteral(ileft, i.intValue()); :}
		;

